## Завдання

Маємо набір монет `[50, 25, 10, 5, 2, 1]`. Уявіть, що ви розробляєте систему для касового апарату, яка повинна визначити оптимальний спосіб видачі решти покупцеві.

Вам необхідно написати дві функції для касової системи, яка видає решту покупцеві:

- Функція жадібного алгоритму `find_coins_greedy`. Ця функція повинна приймати суму, яку потрібно видати покупцеві, і повертати словник із кількістю монет кожного номіналу, що використовуються для формування цієї суми. Наприклад, для суми `113` це буде словник `{50: 2, 10: 1, 2: 1, 1: 1}`. Алгоритм повинен бути жадібним, тобто спочатку вибирати найбільш доступні номінали монет.
- Функція динамічного програмування `find_min_coins`. Ця функція також повинна приймати суму для видачі решти, але використовувати метод динамічного програмування, щоб знайти мінімальну кількість монет, необхідних для формування цієї суми. Функція повинна повертати словник із номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом. Наприклад, для суми `113` це буде словник `{1: 1, 2: 1, 10: 1, 50: 2}`

Порівняйте ефективність жадібного алгоритму та алгоритму динамічного програмування, базуючись на часі їх виконання або О великому та звертаючи увагу на їхню продуктивність при великих сумах. Висвітліть, як вони справляються з великими сумами та чому один алгоритм може бути більш ефективним за інший у певних ситуаціях. Свої висновки додайте у файл `readme.md` завдання.

---

## Висновки щодо ефективності жадібного алгоритму та алгоритму динамічного програмування

Після проведення розрахунків для набору сум `amounts = [15, 40, 113, 175, 450, 1113]` і вимірювання часу виконання обох алгоритмів, можна зробити наступні висновки:

**1. Жадібний алгоритм:**

- **Часова складність:** Жадібний алгоритм має лінійну складність `O(n)`, де `n` — кількість номіналів монет. У нашому випадку кількість монет є сталою (6 монет: [50, 25, 10, 5, 2, 1]), тому час виконання для будь-якої суми буде дуже швидким.
- **Продуктивність:** Жадібний алгоритм працює дуже швидко навіть для великих сум. Для кожної з сум алгоритм виявився дуже ефективним, оскільки він просто намагається взяти найбільші доступні монети.
- **Оптимальність результату:** Жадібний алгоритм гарантує мінімальну кількість монет для випадків, коли номінали монет побудовані так, що більші монети завжди кратні меншим (що є нашим випадком). Для монет [50, 25, 10, 5, 2, 1] він завжди знаходить оптимальне рішення.

**2. Алгоритм динамічного програмування:**

- **Часова складність:** Алгоритм динамічного програмування має складність O(m \* n), де m — це сума, яку потрібно видати, а n — кількість номіналів монет. Це означає, що час виконання зростає пропорційно до суми. Для більших сум, як-от 1113, алгоритм динамічного програмування працює повільніше порівняно з жадібним.
- **Продуктивність:** Для менших сум алгоритм динамічного програмування працює досить швидко, але для великих сум (наприклад, 1113) час виконання значно збільшується через необхідність обчислень для кожної проміжної суми. Однак алгоритм все одно залишався прийнятно швидким у контексті даного завдання.
- **Оптимальність результату:** Алгоритм динамічного програмування гарантує мінімальну кількість монет для будь-якого набору монет, навіть якщо набір не задовольняє критерії жадібності (що не є нашою проблемою). Він завжди знаходить найкраще рішення.

**Порівняння:**

- **Час виконання:** Жадібний алгоритм стабільно випереджає алгоритм динамічного програмування по часу виконання, особливо при великих сумах. Для кожної суми жадібний алгоритм був швидшим через його простішу логіку та меншу кількість обчислень.
- **Оптимальність:** Обидва алгоритми забезпечують оптимальні результати для нашого конкретного набору монет, тому що більші монети кратні меншим. У складніших наборах, де така властивість не дотримується, алгоритм динамічного програмування надасть перевагу, але для даного випадку жадібний алгоритм є і швидшим, і достатньо оптимальним.

Жадібний алгоритм підходить краще для реальних умов, коли потрібно швидко визначити кількість монет для видачі решти в касовій системі, оскільки він завжди дає правильний результат і працює швидше.

Алгоритм динамічного програмування варто використовувати в ситуаціях, коли набір монет не гарантує оптимальних рішень за допомогою жадібного підходу або в контекстах, де важливо точно знати мінімальну кількість монет, незалежно від часу виконання.
